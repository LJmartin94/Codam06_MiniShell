


//Built-in commands are contained within the shell itself. When the name of a built-in command is used as the first word of a simple command, the shell executes the command directly, without creating a new process. Built-in commands are necessary to implement functionality impossible or inconvenient to obtain with separate utilities.



//TODO: Tests:
/*
while true; do rm file ; echo "123" > file | echo "abcdefg" > file ; cat file ; echo ------; sleep 1; done

rm file ; echo "123" > file | echo "abcdefg" > file
> cat file
123
efg
rm file ; echo "123" > file | echo "abcdefg" > file
> cat file
123
rm file ; echo "123" > file | echo "abcdefg" > file
> cat file
abcdefg
*/


/*
** > env -i bash
bash-3.2$ env
PWD=/Users/jules/projects/codam/minishell
SHLVL=1
_=/usr/bin/env

//TODO: ls doesn't have to work if path is not set from the start. Also if path is unset during testing, it doesn't have to find path
//TODO: what is the _ env variable
*/

//TODO: Shell doesn't handle closing infinite processes

//TODO: fd leaks????spooky

and you can try this one Echo ; echo \n ' \n this is the; "first line"' ; echo "and right here;;; 'We have the second'" ; echo and" a fe"'w 'here'; with some slash and quotes  .'  '\' ; echo '\\' ; echo "\\" ; echo   "\"" ; echo  \\ ; echo  \' ; echo  \" "\\"   "\""  \\  \'  \"echo 00\\\'pp ; echo 00\\\\\'pp ; echo 00\\\\'pp' ; echo "./hello".; echo ./hello ; echo ello to see if they function properly


// $> base64 /dev/urandom | head -c 1000 | rev | cat -e | cut -d 'x' -f 1,3,5 >> /tmp/toto.txt; cat /tmp/toto.txt; rm /tmp/toto.txt
// $> base64 < /dev/urandom | head -c 1000 | grep 42 | wc -l | sed -e s/1/Yes/g -e s/0/No/g; ps a | grep 'base64' | grep -v 'grep' <- this doesn't work due to parsing

//In what order should things execute? Redirections occur before command finishes, other commands wait for previosu commands to finish, pipes don't wait for previous commands to finish




yes | head -n 5 | tail -n 5 | grep -c y > file.txt ; cat file.txt ; rm file.txt
THIS SOMETIMES PRINTS 5, SOMETIMES 0 and SOMETIMES NOTHING



cat /dev/urandom | head -c10 (should stop, if it is hanging, something is wrong. could be fd's that you didn't close properly, could be incorrect implementation of pipes)
sleep 42 | sleep 1 (if you pgrep sleep after a second, it should only give 1 pid as output. or check with htop/top/ps)
cat | grep 42 (should output any line you enter that contains 42, right after you submit it. if it only outputs the lines containing 42 after you ctrl+d, your processes are not running at the same time.)



exit | echo


export ls="ls    -la" ; $ls

// weirdness:
ft_strncmp(item, data->key, ft_strlen(data->key) + 1)

echo /$"123$USER"

base64 < /dev/random | head -c 1000 | cat -e

 exit 1 | exit 2 | exit 3 | exit 4 ; echo $?

 echo hoi | notacommand | cat -e

 export hoi=hallo wazap test1= 34rip _yo=12; export; echo; env;
 exit 1 | exit 2 | notacommand | exit 4; echo $?
 cat | notacommand | echo hoi
 echo > file1 abel >> file2 is een > file3 gekke man >:O
 cat < Makefile > file
 chmod 000 minishell; ./minishell; echo $?
 e'c'"h"o wadup 
 cat | cat -e | cat | cat -e | cat | cat -e | cat | cat -e
//TODO: export ls="ls -la ; ls" <- will pring permission denied. Waiting for parsing




//TODO: Things that still fail in the parser:

- Backslash before a char when between quotes?

echo "\poep"
echo "hallo\"\poep"
echo $"\hallo"

export AA"AA"AA=AA
export AA"AA"AA="AA"
export AA"AA"AA= "AA"
export AA"AA"AA ="AA"
export AA"AA"AA=" AA"
export AA" AA"AA=" AA"

unset AA" AA"AA
unset AA "AA"AA
unset AAAAAA
unset AAAAA



export ; export a="\\" ; export b='\\' ; export c="\b" ; export


< notworking.tx




ls -la srcs .. (<-- prints results in wrong order?)